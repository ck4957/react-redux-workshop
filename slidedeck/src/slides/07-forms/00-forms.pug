section
  h1 Forms

section
  p Form fields hold internal state from user interactions
  script(type="text/plain", class="language-jsx").
    <form>
      <label>
        Name:
        <input type="text" name="name" />
      </label>
      <input type="submit" value="Submit" />
    </form>

section
  p Form components allow listening for changes
  ul
    li Set a callback to the <span class="component red">onChange</span> prop
    li The callback fires when:
      ul
        li The value changes (every keystroke)
        li Checked state changes (checkbox)
        li Selected value changes (select dropdown)
  script(type="text/plain", class="language-jsx").
    <input type="text" name="name" onChange={this.onNameChange} />

section
  h2 Controlled vs Uncontrolled Components

section
  h3 Uncontrolled Components
  ul
    li State and display are managed outside React
    li React can be notified when it changes

  script(type="text/plain", class="language-jsx").
    onCityChange(event) {
      console.log(`Value changed to ${event.target.value}`);
    }

    <input type="text" onChange={this.onCityChange} />

section
  h3 Controlled Components
  ul
    li React controls state and display
    li Value of the rendered element will always reflect the <span class="component red">value</span> prop
    li Allows for setting initial state, overriding/transforming changes
  script(type="text/plain", class="language-jsx").
    handleCityChange(event) {
      this.setState({city: {value: event.target.value}});
    }

    <input type="text" value={this.state.city.value}
           onChange={this.handleCityChange} />

section
  h3 Forms are hard
  ul
    li Inherently working with user-supplied (dangerous!) data
    li Need to pre-populate, auto-format, validate, marshal data
    li Error handling is tricky
    li Dynamic aspects are hard to manage manually

section
  h3 What do we do?
  p You can do all of your forms manually if you want
  p Highly recommend using a third-party library
  p Lots of options, simple (basic) to complex (highly capable)

section
  h2 React Bootstrap

section
  h2 React Bootstrap
  p Bootstrap styles for form components in React
  p One of the more basic (but boilerplate-heavy) options

  script(type="text/plain", class="language-jsx").
    <FormGroup controlId="firstName">
      <ControlLabel>First Name</ControlLabel>
      <FormControl
        type="text"
        value={this.state.firstName.value}
        placeholder="Enter firstName"
        onChange={(e) => this.handleFirstNameChange(e.target.value)}
      />
    </FormGroup>

section
  h2 React Bootstrap Validation
  ul
    li Add a validationState function to return one of success, warning, or error
    li Add <span class="component red">&lt;FormControl.Feedback/></span> inside the FormGroup tag

section
  h3 React Bootstrap Validation
  script(type="text/plain", class="language-jsx").
    <FormGroup
      controlId="firstName"
      validationState={this.getFirstNameValidationState()}
    >
      <ControlLabel>First Name</ControlLabel>
      <FormControl
        type="text"
        value={this.state.firstName.value}
        placeholder="Enter firstName"
        onChange={(e) => this.handleFirstNameChange(e.target.value)}
      />
      <FormControl.Feedback />
    </FormGroup>

section
  h3 React Bootstrap State
  p Validation and value state must be managed manually
  script(type="text/plain", class="language-jsx").
    getFirstNameValidationState() {
      if (!this.state) return;
      if (this.state.firstName.valid === true) return 'success';
      else if (this.state.firstName.valid === false) return 'error';
    }

    handleFirstNameChange(value) {
      const isValid = value ? true : false;
      return this.setState(
        { firstName: {value: value, valid: isValid }}
      );
    }

section
  a(href="https://github.com/jaredpalmer/formik", target="_blank", rel="noopener")
    img(src="~./images/formik.png")

section
  h2 Formik
  p No styling but handles more Form logic

  script(type="text/plain", class="language-jsx").
    <Formik
      initialValues={{ firstName: 'Bob' }}
      validate={this.validate}
      onSubmit={this.submit}
    >
      {() => (
        <Form>
          <Field type="text" name="firstName" />
          <ErrorMessage name="firstName" />

          <button type="submit">Submit</button>
        </Form>
      )}
    </Formik>


section
  h2 Formik Validation
  ul
    li Validate the whole form when any field changes
    li Sends any validation failures back to form

section
  h3 Formik Validation
  script(type="text/plain", class="language-jsx").
    <Formik
      ...
      validate={this.validate}
    >

    const validate = (values) => {
      const errors = {};
      if (!values.firstName) {
        errors.firstName = 'Required!';
      }
      return errors;
    };

section
  h3 Formik State
  p Formik handles tracking form values for us (no 'handle' functions)
  p We'll get a copy of all values on validation & submission

  script(type="text/plain", class="language-jsx").
    <Formik
      ...
      onSubmit={this.submit}
    >

    const submit = (values) => {
      // Do stuff to submit the form here
    };

section
  h3 Other libraries

section
  a(href="https://github.com/final-form/react-final-form", target="_blank", rel="noopener")
    img(src="~./images/react-final-form.png")

section
  h3 Choose what you like best
  h4 Or no library!
  p One popular opinion:
  blockquote(cite="Dan Abramov") [form state] is inherently ephemeral and local, so tracking it in Redux (or any kind of Flux library) is unnecessary

section
  h1
    a(href="/labs/forms-and-validation") Lab 5
  h2 React Form Validation
