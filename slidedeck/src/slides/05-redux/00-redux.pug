section
  h1 Redux

section
  h2 What is Redux?
  p A place to store long-lived data outside of React Components
  p ...and a formalized way to modify that data

section
  h3.lower Three principles
  ul
    li Single source of truth - object tree in a single store
    li State is read-only - can only be changed by dispatching an action
    li Changes are made with pure functions called <span class="component red">reducers</span>

section
  h3 What is a pure function?

  script(type="text/plain", class="language-js").
    function add(a, b) {
      return a + b;
    }

    add(2, 2); // always 4

section
  h2 Benefits

section
  h3 Predictability
  ul
    li State mutation is more predictable by imposing restrictions on updating
    ul
      li Actions are handled in a strict order
      li Actions can be recorded and replayed

section
  h3 Centralization
  ul
    li Centralized state helps avoid race conditions and side effects
    li Allows for centralized handling of concerns
    ul
      li Logging
      li Undo/Redo
      li State persistence

section
  h3 Safety
  p Dozens of components could be attempting to read/write at once
  p State mutation via Redux ensures safe, predictable changes

section
  h2 Core Concepts

section
  h3 Actions
  ul
    li.
      Plain JavaScript objects that have a <span class="component red">type</span> that describes the action being performed
    li Objects can contain just about anything else
    li Best practice to establish a convention or use tools like
      a(href="https://github.com/redux-utilities/flux-standard-action")  Flux Standard Actions

section
  h3 Action Creators
  ul
    li Function that creates and returns an action
  script(type="text/plain", class="language-jsx", style="width:100%").
    // action type
    const ADD_AGENT = 'ADD_AGENT'

    // action creator
    const addAgent = agent => {
      return {
        type: ADD_AGENT,
        payload: agent
      }
    }

section
  h3 Reducers
  script(type="text/plain", class="language-jsx", style="width:100%").
    const initialState = {
      agents: []
    }

    const agentReducer = (state = initialState, action) => {
      switch (action.type) {
        case 'ADD_EMPLOYEE':
          return {
            ...state,
            agents: [...state.agents, ...action.payload]
          };
          ...
      }
    }

section
  h3 Immutability
  h4 Good
  script(type="text/plain", class="language-js").
    case 'ADD_EMPLOYEE':
      return {
        ...state,
        agents: [...state.agents, ...action.payload]
      };

  h4 Bad
  script(type="text/plain", class="language-js").
    case 'ADD_EMPLOYEE':
      state.agents = state.agents.concat(action.payload);
      return state;

section
  h3 Immutability
  p
    | Consider using a library like
    a(href="https://github.com/rtfeldman/seamless-immutable")  seamless-immutable
    |  or
    a(href="https://github.com/mweststrate/immer")  immer
    |  to prevent accidental state mutation

section
  iframe(src="https://codesandbox.io/embed/82l7p64vrl", style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;", sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin")
